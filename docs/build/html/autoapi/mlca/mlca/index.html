<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>mlca.mlca &#8212; multi-Lvl-Coincidence Analysis  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="mlca.plot_graph" href="../plot_graph/index.html" />
    <link rel="prev" title="mlca.gui" href="../gui/index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-mlca.mlca">
<span id="mlca-mlca"></span><h1>mlca.mlca<a class="headerlink" href="#module-mlca.mlca" title="Link to this heading">¶</a></h1>
<p>This file contains the main functions of multi-Lvl-Coincidence-Analysis (mLCA), a package to
generate multi-level causal-mechanistic models from Boolean data tables that are provided with
tiered list of causal factors (assignment to constitutive levels).</p>
<p>The data tables can be processed in three different ways:</p>
<ol class="upperalpha simple">
<li><p>as csv-files with Boolean data (for details on formatting requirements
see README),</p></li>
<li><p>reading the atomic solutions from the output of the R-package cna,</p></li>
<li><p>or from the output of the QCA package.</p></li>
</ol>
<p>If any of the two latter options is used, it is assumed that causal factors pertaining to
different levels are separated by the causal ordering relation “&lt;”.
Relations between factors of different levels are not considered as causal but constitution relations.</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.mlca.is_transitive" title="mlca.mlca.is_transitive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_transitive</span></code></a>(→ tuple[list, bool])</p></td>
<td><p>Function that checks whether the list of causal relations is transitive for the causal factors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.mlca.reduce_structural_redundancy" title="mlca.mlca.reduce_structural_redundancy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_structural_redundancy</span></code></a>(→ tuple[bool, list])</p></td>
<td><p>Reduces the list of equivalence relations to dissolve structural redundancies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.mlca.minimise_constitution_relations" title="mlca.mlca.minimise_constitution_relations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimise_constitution_relations</span></code></a>(→ tuple)</p></td>
<td><p>Transforms constitution relations and discards inaccurate constitution relations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.mlca.arrange_factors" title="mlca.mlca.arrange_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arrange_factors</span></code></a>(→ tuple)</p></td>
<td><p>Prepares the factor list for plotting such that the nodes are arranged to minimise crossings of vertices in the hypergraph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.mlca.read_input" title="mlca.mlca.read_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_input</span></code></a>(→ tuple)</p></td>
<td><p>Obtains the relevant data from the R output of either QCA or CNA and returns two lists:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.mlca.categorise_formulae" title="mlca.mlca.categorise_formulae"><code class="xref py py-obj docutils literal notranslate"><span class="pre">categorise_formulae</span></code></a>(→ tuple)</p></td>
<td><p>Separates the equivalence relations in causal relations (subdivided by their constitutive level) and constitution relations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.mlca.determine_factor_order" title="mlca.mlca.determine_factor_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">determine_factor_order</span></code></a>(→ list)</p></td>
<td><p>Uses the list of causal relations in level_equiv_list to determine a total causal ordering of the causal factors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.mlca.reduce_redundancies" title="mlca.mlca.reduce_redundancies"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_redundancies</span></code></a>(→ tuple)</p></td>
<td><p>Determines the (non-strict) transitive order of the causal factors and</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.mlca.find_conflicting_formulae" title="mlca.mlca.find_conflicting_formulae"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_conflicting_formulae</span></code></a>(→ dict)</p></td>
<td><p>Function that searches in a list of tupels for elements that share the second value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.mlca.convert_tuple_list_to_nested_list" title="mlca.mlca.convert_tuple_list_to_nested_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_tuple_list_to_nested_list</span></code></a>(→ list)</p></td>
<td><p>Transforms lists of tuples into a nested list and returns the nested list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.mlca.find_structures" title="mlca.mlca.find_structures"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_structures</span></code></a>(→ list)</p></td>
<td><p>This functions combines the causal relations to solutions for the underlying multi-level structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.mlca.create_separate_formula_list" title="mlca.mlca.create_separate_formula_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_separate_formula_list</span></code></a>(→ None)</p></td>
<td><p>Creates a text file listing all possible causal structures as tex-formulae.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.is_transitive">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">is_transitive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlca.mlca.is_transitive" title="Link to this definition">¶</a></dt>
<dd><p>Function that checks whether the list of causal relations is transitive for the causal factors
from factor_list, e.g., A-&gt;B, B-&gt;C is transitive, but A-&gt;B, B-&gt;C, C-&gt;A is not.</p>
<p>If it is transitive, the function defines a causal ordering on factor_list and returns
it in a nested list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula_list</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – list of equivalence formulae, first element</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>list</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>list</em><em> of </em><em>str</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>bool</em> – True if value whether transitive
False otherwise</p></li>
<li><p><strong>order_factor_list</strong> (<em>list of lists of str or list of str</em>) – If first returned value is False, return the initial factor_list.
If first returned value is True, return a nested list of causal factors
subdivided by their causal order of the form order_factor_list[ORDER][FACTOR].
list is empty if factor_list is empty</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.reduce_structural_redundancy">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">reduce_structural_redundancy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">formula_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduced_solutions_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">already_tested</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlca.mlca.reduce_structural_redundancy" title="Link to this definition">¶</a></dt>
<dd><p>Reduces the list of equivalence relations to dissolve structural redundancies.</p>
<p>All factors that are causally connected through formula_list remain causally connected,
while a linear ordering of the causal factors can be defined, which is only interesting in
case that this is not possible for formula_list itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>str</em>) – list of factors, expected to contain all variables of formulae from formula_list</p></li>
<li><p><strong>formula_list</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – list equivalence relations represented as tuples, first element corresponds to the
complex DNF-term, second element to the atomic term</p></li>
<li><p><strong>reduced_solutions_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>tuples</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – list of formula lists that are free of structural redundancies, with recursive
invocations of this function, elements get added to this list</p></li>
<li><p><strong>already_tested</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>tuples</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – list to keep track of formual lists that have already been tested for
being redundancy-free, every formula_list gets added to avoid testing the same
formula list several times</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>bool</em> – truth value whether structural redundancy-free solutions have been found</p></li>
<li><p><em>list</em> – list of formula lists that correspond to non-circular solutions that are logically
equivalent to formula_list if any has been found;
OR the list contains only the incomming formula_list if no non-circular solution has been found</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.minimise_constitution_relations">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">minimise_constitution_relations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level_factor_list_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_equiv_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constitution_relation_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.mlca.minimise_constitution_relations" title="Link to this definition">¶</a></dt>
<dd><p>Transforms constitution relations and discards inaccurate constitution relations.</p>
<p>Constitution relations are inaccurate if the lower order factors are in fact constituents of an upstream higher order factor
relative to the higher order factor that appears in the constitution relation.
steps:</p>
<ol class="arabic">
<li><p>constitution relations are rewritten, complex formulae in the constituents are split up into separate constitution
relations (e.g. (‘A*B’,’C’) becomes (‘A’,’C’),(‘B’,’C’)
in this step, an individual list for each higher order factor for which constitution relations exist is created</p></li>
<li><ol class="upperalpha simple">
<li><p>find the highest order of constituents -&gt; factors of this order are kept for sure</p></li>
<li><p>determine the lowest order that should be kept</p></li>
</ol>
<blockquote>
<div><ol class="lowerroman simple">
<li><p>if the higher level factor is of order 0 (on level m), factors of downto order 0 (on level m-1) should be kept</p></li>
<li><p>if the higher level factor is of a higher order, its lowest factors must not be in constitution relation
with the factor’s causal pre-factors</p></li>
</ol>
</div></blockquote>
</li>
<li><p>discard constitution relations to terms that are middle terms of causal chains whose
upstream and downstream factors are also in a constitution relation with the considered higher level factor</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level_factor_list_order</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list of factors in form of level_factor_list_order[LEVEL][ORDER][FACTOR]</p></li>
<li><p><strong>level</strong> (<em>int</em>) – index of the considered constitutive level</p></li>
<li><p><strong>level_equiv_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – nested list of equivalence relations (causal) represented as tuples, first element corresponds to the
complex DNF-term, second element to the atomic term</p></li>
<li><p><strong>constitution_relation_list</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – list of equivalence relations (constitutive) represented as tuples, first element corresponds to the
complex DNF-term, second element to the atomic term</p></li>
<li><p><strong>color_map</strong> (<em>dict</em>) – dictionary of the form [STYLE][FACTOR] that contains for each factor in which color the nodes are drawn
(STYLE=’draw’), and the labels are written (STYLE=’text’)</p></li>
<li><p><strong>color_index</strong> (<em>int</em>) – index of the color in which the constitution relations will be drawn,
color index values 0,1,…,11 are defined in Latex_Template</p></li>
<li><p><strong>mode</strong> (<em>list</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – list of special options, such as black-white plotting, empty list means that no special option is used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>list of tuples of str</em> – reduced list of constitution relations</p></li>
<li><p><em>dict</em> – modified color_map</p></li>
<li><p><em>int</em> – color_index of color for next constitution relation</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.arrange_factors">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">arrange_factors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level_factor_list_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_equiv_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constitution_relation_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.mlca.arrange_factors" title="Link to this definition">¶</a></dt>
<dd><p>Prepares the factor list for plotting such that the nodes are arranged to minimise crossings of vertices in the hypergraph.</p>
<ol class="upperalpha simple">
<li><p>factors of same level and order zero are grouped when belonging to the same constitution relation</p></li>
<li><p>factors of same level and subsequent orders are arranged such that arrow crossing in the causal graphs becomes minimised
(in a very rudimentary way)</p></li>
<li><p>discards constitution relations for middle terms</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level_factor_list_order</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list of factors in form of level_factor_list_order[LEVEL][ORDER][FACTOR]</p></li>
<li><p><strong>level_equiv_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – nested list of equivalence relations (causal) represented as tuples, first element corresponds to the
complex DNF-term, second element to the atomic term</p></li>
<li><p><strong>constitution_relation_list</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – list of equivalence relations (constitutive) represented as tuples, first element corresponds to the
complex DNF-term, second element to the atomic term</p></li>
<li><p><strong>mode</strong> (<em>list</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – list of special options, such as black-white plotting, empty list means that no special option is used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>list of lists of lists of str</em> – modified level_factor_list_order</p></li>
<li><p><em>list of tuples of str</em> – modified constitution_relation_list</p></li>
<li><p><em>dict</em> – dictionary of the form [STYLE][FACTOR] that contains for each factor in which color the nodes are drawn
(STYLE=’draw’), and the labels are written (STYLE=’text’)</p></li>
<li><p><em>list of lists of tuples of str</em> – modified level_equiv_list</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.read_input">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">read_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.mlca.read_input" title="Link to this definition">¶</a></dt>
<dd><p>Obtains the relevant data from the R output of either QCA or CNA and returns two lists:</p>
<ol class="arabic simple">
<li><p>level_factor_list - list of causal factors separated into one sublist for each constitutive level,</p></li>
<li><p>equiv_list - list of equivalence formulae</p></li>
</ol>
<p>Functionality depends on the output syntax of both R-packages and is adapted to CNA version 3.5.4;
QCA version 3.21.
This function has to be adjusted to any changes in the output formatting of these packages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_name</strong> (<em>str</em>) – path to the text file containing the results from QCA or CNA</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>bool</em> – truth value of whether an error occured while reading and evaluating file_name</p></li>
<li><p><em>list of lists of str</em> – nested list of factors, in form level_factor_list[LEVEL][FACTOR]</p></li>
<li><p><em>list of tuples of str</em> – list of equivalence relations in form of tuples</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.categorise_formulae">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">categorise_formulae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">equiv_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.mlca.categorise_formulae" title="Link to this definition">¶</a></dt>
<dd><p>Separates the equivalence relations in causal relations (subdivided by their constitutive level) and constitution relations.
All further equivalence relations from equiv_list are discarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>equiv_list</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – list of equivalence relations in form of tuples</p></li>
<li><p><strong>level_factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list factors, expected to contain all variables of formulae from equiv_list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>list of lists of tuples of str</em> – nested list causal relations per constitutive level, in form of
level_equiv_list[LEVEL][FORMULA](COMPLEX_TERM,ATOMIC_TERM)</p></li>
<li><p><em>list of tuples of str</em> – list constitution relations</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.determine_factor_order">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">determine_factor_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level_factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_equiv_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.mlca.determine_factor_order" title="Link to this definition">¶</a></dt>
<dd><p>Uses the list of causal relations in level_equiv_list to determine a total causal ordering of the causal factors
in level_factor_list for each level separately.</p>
<p>Returns the new factor list level_factor_list_order that is nested twice by level and causal order
level_factor_list_order[LEVEL][ORDER][FACTOR].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level_factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list factors, expected to contain all variables of formulae from equiv_list</p></li>
<li><p><strong>level_equiv_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – nested list of equivalence relations per level in form of tuples</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>level_factor_list_order that is nested twice by level and causal order in form of
level_factor_list_order[LEVEL][ORDER][FACTOR]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of lists of lists of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.reduce_redundancies">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">reduce_redundancies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level_factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_equiv_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.mlca.reduce_redundancies" title="Link to this definition">¶</a></dt>
<dd><p>Determines the (non-strict) transitive order of the causal factors and
adapts the causal order to particular solution.</p>
<p>Returns all models that can be generated from level_equiv_list by removing
redundancies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level_factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list factors, expected to contain all variables of formulae from equiv_list</p></li>
<li><p><strong>level_equiv_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – nested list of equivalence relations per level in form of tuples</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>bool</em> – truth value of non-circularity of obtained models</p></li>
<li><p><em>list of tuples</em> – list of models in form of pairs of nested factor list (by level and order),
and nested causal relations list (by level)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.find_conflicting_formulae">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">find_conflicting_formulae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solution</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlca.mlca.find_conflicting_formulae" title="Link to this definition">¶</a></dt>
<dd><p>Function that searches in a list of tupels for elements that share the second value.</p>
<p>In the context of mLCA, the function finds all conflicting causal relations (those to a same effect) in a proposed model
and returns them ordered by effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>solution</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – list of equivalence relations per level in form of tuples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary whose keys are the multiple second tuple-values and the assigned dictionary-values are lists of the corresponding
first tuple-values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.convert_tuple_list_to_nested_list">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">convert_tuple_list_to_nested_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.mlca.convert_tuple_list_to_nested_list" title="Link to this definition">¶</a></dt>
<dd><p>Transforms lists of tuples into a nested list and returns the nested list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>in_list</strong> (<em>list</em>) – list of tuples or nested list</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a nested list, in case that in_list is a list of tuples, the tuples are transformed
into sublists</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of lists</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.find_structures">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">find_structures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_level_factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_level_equiv_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['bw',</span> <span class="pre">'simple']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_caus_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_caus_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.mlca.find_structures" title="Link to this definition">¶</a></dt>
<dd><p>This functions combines the causal relations to solutions for the underlying multi-level structure.
Each solution consists of a minimal set of causal relations to causally connect every causal factor.
find_structures returns a list with all valid solutions in form of a list of solutions, which are nested lists of causal relations
per constitutive level in the form of solutions_list[SOLUTION][LEVEL][CAUSAL RELATION].</p>
<p>Since combining all causal relations that can logically be generated from the truth table
can lead to various causal relations for the same effect, as well as formulae where an effect
might appear as cause of its own cause, some formulae have to be ignored when creating
the causal structure of the mechanism. This happens with the following steps:
for each consitution level separate steps:</p>
<ol class="upperalpha simple">
<li><p>find circular sub-structures</p></li>
<li><p>discard as many causal relations as necessary to get rid of all simple circularities</p></li>
<li><p>find causal relations that have the same effect</p></li>
<li><p>compose the list of all valid solutions (it consists of all combinations of valid solution
each consisting of one formula per effect of step A combined with one possible resolution of
circularities and those formulae that are the common core of all valid structures)
combining the partial solutions for each constitutive level</p></li>
<li><p>Cartesian product of the partial solutions - also discard dublicates of solutions and solutions
that only differ in the order of formulae</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_level_factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list of lists of causal factors per constitutive level</p></li>
<li><p><strong>in_level_equiv_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>tuples</em><em> of </em><em>str</em>) – nested list of lists of equivalence relations per constitutive level (all of them are interpreted as causal relations)</p></li>
<li><p><strong>mode</strong> (<em>list</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – <dl class="simple">
<dt>list of options: “simple” is faithful to the INUS theory of causation (default option),</dt><dd><dl class="simple">
<dt>”complex” emits further models with more complex relations between co-extensive</dt><dd><p>factors (not only A &lt;-&gt; B, B &lt;-&gt; C, etc., but also A*B &lt;-&gt; C, A + B &lt;-&gt; C)</p>
</dd>
</dl>
</dd>
</dl>
</p></li>
<li><p><strong>pos_caus_cond</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – list of equivalence relations that are required to appear in each model (by default empty) # MARKER TO-DO to be integrated into the code</p></li>
<li><p><strong>neg_caus_cond</strong> (<em>list</em><em> of </em><em>tuples</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – list of equivalence relations that must not appear in any model (by default empty) # MARKER TO-DO to be integrated</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of all valid solutions in the form of solutions_list[SOLUTION][LEVEL][CAUSAL RELATION]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of lists of lists of tuples of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.mlca.create_separate_formula_list">
<span class="sig-prename descclassname"><span class="pre">mlca.mlca.</span></span><span class="sig-name descname"><span class="pre">create_separate_formula_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#mlca.mlca.create_separate_formula_list" title="Link to this definition">¶</a></dt>
<dd><p>Creates a text file listing all possible causal structures as tex-formulae.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>formula_list</strong> (<em>list</em><em> of </em><em>str</em>) – list of formulae to be exported in tex-file, expected to be already converted
into tex-syntax</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/mlca-logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">Causal-mechanistic modeling using Coincidence Analysis</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=5vckcq&repo=multi-Lvl-Coincidence-Analysis&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">mlca</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../atomic_formulae/index.html">mlca.atomic_formulae</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cli/index.html">mlca.cli</a></li>
<li class="toctree-l4"><a class="reference internal" href="../gui/index.html">mlca.gui</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">mlca.mlca</a></li>
<li class="toctree-l4"><a class="reference internal" href="../plot_graph/index.html">mlca.plot_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utils/index.html">mlca.utils</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">API Reference</a><ul>
  <li><a href="../index.html">mlca</a><ul>
      <li>Previous: <a href="../gui/index.html" title="previous chapter">mlca.gui</a></li>
      <li>Next: <a href="../plot_graph/index.html" title="next chapter">mlca.plot_graph</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Johannes Mierau.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/autoapi/mlca/mlca/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>