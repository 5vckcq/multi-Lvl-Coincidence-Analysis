<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>mlca.atomic_formulae &#8212; multi-lvl-Coincidence Analysis  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="mlca.cli" href="../cli/index.html" />
    <link rel="prev" title="mlca" href="../index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-mlca.atomic_formulae">
<span id="mlca-atomic-formulae"></span><h1>mlca.atomic_formulae<a class="headerlink" href="#module-mlca.atomic_formulae" title="Link to this heading">¶</a></h1>
<p>Functions to derive atomic solution formulae from Boolean coincidence data tables</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.atomic_formulae.list_to_string" title="mlca.atomic_formulae.list_to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list_to_string</span></code></a>(in_list)</p></td>
<td><p>Converts a nested list of the form in_list[DISJUNCT][CONJUNCT] or</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.atomic_formulae.string_to_list" title="mlca.atomic_formulae.string_to_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">string_to_list</span></code></a>(st)</p></td>
<td><p>Converts a string into nested list:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.atomic_formulae.find_effects" title="mlca.atomic_formulae.find_effects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_effects</span></code></a>(→ list)</p></td>
<td><p>Determines which elements from factor_list are dependent variables (effects)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.atomic_formulae.get_instance_formula_to_factor" title="mlca.atomic_formulae.get_instance_formula_to_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_instance_formula_to_factor</span></code></a>(→ dict)</p></td>
<td><p>Derives the instance function for factor from the formula in_formula.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.atomic_formulae.reduce_term_by" title="mlca.atomic_formulae.reduce_term_by"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_term_by</span></code></a>(→ str)</p></td>
<td><p>Removes the string literal from the string term. If term starts</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.atomic_formulae.contains_term" title="mlca.atomic_formulae.contains_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains_term</span></code></a>(→ bool)</p></td>
<td><p>Checks whether original_term contains all substrings of comparison_term,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.atomic_formulae.absorb_terms" title="mlca.atomic_formulae.absorb_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">absorb_terms</span></code></a>(→ list)</p></td>
<td><p>Applies the absorption rule a*b*c*d*e + a*c*d &lt;-&gt; a*c*d to simplify a DNF which is</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.atomic_formulae.distribution" title="mlca.atomic_formulae.distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distribution</span></code></a>(→ str)</p></td>
<td><p>Applies the distribution rule on a logical formula given as a string as often as possible,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.atomic_formulae.get_prime_implicants" title="mlca.atomic_formulae.get_prime_implicants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_prime_implicants</span></code></a>(→ list)</p></td>
<td><p>Applies the Quine-McCluskey algorithm to obtain prime implicants by comparing the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.atomic_formulae.get_rdnf" title="mlca.atomic_formulae.get_rdnf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_rdnf</span></code></a>(→ list)</p></td>
<td><p>Obtains reduced disjunctive normal form using Petrick's algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.atomic_formulae.get_truth_table_from_file" title="mlca.atomic_formulae.get_truth_table_from_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_truth_table_from_file</span></code></a>(→ tuple)</p></td>
<td><p>Reads a csv file into a pandas data frame with Boolean entries.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.atomic_formulae.read_data_from_csv" title="mlca.atomic_formulae.read_data_from_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_data_from_csv</span></code></a>(→ tuple)</p></td>
<td><p>Main function of atomic_formulae.py.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.list_to_string">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">list_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlca.atomic_formulae.list_to_string" title="Link to this definition">¶</a></dt>
<dd><p>Converts a nested list of the form in_list[DISJUNCT][CONJUNCT] or
a list simple list of the form in_list[CONJUNCT] into a string
which connects disjuncts by “ + “ and conjuncts by “*”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>in_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>String elements of list of lowest order are connected by ‘*’,
sublists by ‘ + ‘, if in_list is empty, return ‘’</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.string_to_list">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">string_to_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">st</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlca.atomic_formulae.string_to_list" title="Link to this definition">¶</a></dt>
<dd><p>Converts a string into nested list:
‘ + ‘ separates sublists, ‘*’ elements of the sublists</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>st</strong> (<em>str</em>) – String, expected to express a DNF with disjunctor ‘ + ‘ and
conjunctor ‘*’</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>nested list of form out_list[DISJUNCT][CONJUNCT]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of lists of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.find_effects">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">find_effects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.find_effects" title="Link to this definition">¶</a></dt>
<dd><p>Determines which elements from factor_list are dependent variables (effects)
given the dependencies expressed in formula.</p>
<p>Causal factors are effects only if they do not satisfy either of three conditions:</p>
<ol class="arabic simple">
<li><p>the causal factor is one in every line of the configuration table (in this case they are irrelevant)</p></li>
<li><p>it is zero in every line of the configuration table (same as 1)</p></li>
<li><p>two lines in the table differ only by the value of the factor (this means they might only be first causes)</p></li>
</ol>
<p>These conditions follow M. Baumgartner (2009) “Uncovering deterministic causal structures: a Boolean
approach”, p. 83.</p>
<p>Returns the list of effects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<em>list</em><em> of </em><em>str</em>) – list of string, it is assumed that each element is a conjunctive formula of
the factors appearing from factor_list</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>str</em>) – list of the potential variables of formula</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of elements from factor_list that do not satisfy any of the conditions 1)-3)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.get_instance_formula_to_factor">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">get_instance_formula_to_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_factor_list_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.get_instance_formula_to_factor" title="Link to this definition">¶</a></dt>
<dd><p>Derives the instance function for factor from the formula in_formula.</p>
<p>The instance function of a factor is obtained by removing that factor or its negation from each of the
conjuncts in in_formula and setting its value to True or False respectively.
For computational effiency, formulae that mix different levels and do not satisfy the conditions
on constitution relations are reduced such that factors from other levels than the level of factor
are discarded.</p>
<p>Returns the instance formula as a dictionary in which the formulae (in form of lists) are the keys,
and the respective truth values the corresponding dicitonary values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_formula</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list of strings, expected to have the form [DISJUNCTS][CONJUNCTS]
each conjunct is either a factor from level_factor_list_order or a negated
factor (=’~’ + factor)</p></li>
<li><p><strong>factor</strong> (<em>str</em>) – factor whose instance function is to be generated</p></li>
<li><p><strong>level_factor_list_order</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list of factors, form [LEVEL][CAUSAL_ORDER][FACTOR]
expected to contain all</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary representing the instance function for factor, keys are formulae in form of lists,
the values are Boolean</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.reduce_term_by">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">reduce_term_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">literal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.reduce_term_by" title="Link to this definition">¶</a></dt>
<dd><p>Removes the string literal from the string term. If term starts
with literal, the string literal + ‘*’ is removed from term, otherwise
the string ‘*’ + literal.</p>
<p>It is used to remove literal from a chain of conjuncts in the string term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> (<em>str</em>) – string to be reduced, expected to express a conjunctive
formula with conjunctor ‘*’</p></li>
<li><p><strong>literal</strong> (<em>str</em>) – string which should be removed from term</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>term reduced by literal + ‘*’ or ‘*’ + literal</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.contains_term">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">contains_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_term</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comparison_term</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.contains_term" title="Link to this definition">¶</a></dt>
<dd><p>Checks whether original_term contains all substrings of comparison_term,
possibly not in one piece, but spaced out over original_term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original_term</strong> (<em>str</em>) – string in which is searched for comparison_term</p></li>
<li><p><strong>comparison_term</strong> (<em>str</em>) – string which is searched for</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>truth value of whether original_term contains comparison_term</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.absorb_terms">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">absorb_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.absorb_terms" title="Link to this definition">¶</a></dt>
<dd><p>Applies the absorption rule a*b*c*d*e + a*c*d &lt;-&gt; a*c*d to simplify a DNF which is
passed to this function in form of a nested list.</p>
<p>Returns the simplified DNF as nested list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>arg</strong> (<em>tuple</em>) – <p>arg[0] - is a nested list arg[0][LIST OF CONJUNCTS][CONJUNCTS]
arg[1] - is a nested list, arg[1][LIST OF DISJUNCTS][LIST OF CONJUNCTS][CONJUNCTS],</p>
<blockquote>
<div><p>it should include arg[0]</p>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>nested list of the form [DISJUNCTS][CONJUNCTS] corresponding to
arg[1] after applying the absorption rule</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of lists of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.distribution">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.distribution" title="Link to this definition">¶</a></dt>
<dd><p>Applies the distribution rule on a logical formula given as a string as often as possible,
then applies the absorption rule to simplify the resulting formula as often as possible.</p>
<p>Returns the simplified formula as a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>formula</strong> (<em>str</em>) – expected to express a DNF with disjunctor ‘ + ‘ and conjunctor ‘*’</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>simplified formula after applying distribution and absorption rules</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.get_prime_implicants">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">get_prime_implicants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance_formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.get_prime_implicants" title="Link to this definition">¶</a></dt>
<dd><p>Applies the Quine-McCluskey algorithm to obtain prime implicants by comparing the
min-terms of positive instance function with those of the negative instance function:</p>
<ul class="simple">
<li><p>if a section of one positive min-term is not part of any negative min term,
that positive min-term can be reduced to this section</p></li>
<li><p>if every section is a part of at least one negative min term, the considered term is a prime factor
of the positive instance function</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>instance_formula</strong> (<em>dict</em>) – dictionary with keys: conjunctive formulae in form of lists,
values: truth value</p></li>
<li><p><strong>factor</strong> (<em>str</em>) – factor for whose instance function the prime implicants are derived</p></li>
<li><p><strong>level_factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list of factors, expected to contain all variables in
instance_function and factor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of prime implicants for the instance formula for factor</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.get_rdnf">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">get_rdnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pi_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.get_rdnf" title="Link to this definition">¶</a></dt>
<dd><p>Obtains reduced disjunctive normal form using Petrick’s algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pi_list</strong> (<em>list</em><em> of </em><em>str</em>) – list of prime implicants</p></li>
<li><p><strong>formula</strong> (<em>dict</em>) – dictionary of strings with all values either True or False
= keys are the min terms of the formula, True or False their
truth values</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>str</em>) – expected to express a DNF with disjunctor ‘ + ‘ and conjunctor ‘*’</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>contains all solutions each item is the string of a reduced disjunctive normal form of formula</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.get_truth_table_from_file">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">get_truth_table_from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.get_truth_table_from_file" title="Link to this definition">¶</a></dt>
<dd><p>Reads a csv file into a pandas data frame with Boolean entries.</p>
<p>Returns the list factors (=column heads) and a string expressing
the logical formula that corresponds to the truth table, when
all columns of a row are connected by conjunctors and the rows
by disjunctors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_path</strong> (<em>str</em>) – path to csv-file</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>list of str</em> – list of column heads in csv-file = list of factors</p></li>
<li><p><em>str</em> – logical formula derived from csv-truth table</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.atomic_formulae.read_data_from_csv">
<span class="sig-prename descclassname"><span class="pre">mlca.atomic_formulae.</span></span><span class="sig-name descname"><span class="pre">read_data_from_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.atomic_formulae.read_data_from_csv" title="Link to this definition">¶</a></dt>
<dd><p>Main function of atomic_formulae.py.</p>
<ol class="arabic simple">
<li><p>reads the csv file under file_path
converts the truth table into a logical formula via get_truth_table_from_file
determines the causal factors and any given information on constitution levels and causal order</p></li>
<li><p>derives instance formulae for all causal factors that might be effects from the obtained total formula</p></li>
<li><p>obtains the prime implicants for each instance formula</p></li>
<li><p>transforms the instance formulae into disjunctive normal forms by means of the prime implicants</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_path</strong> (<em>str</em>) – path to csv-file</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>bool</em> – Boolean value for error tracking, False in case that any error occurred (invalid input), True otherwise</p></li>
<li><p><em>list of lists of str</em> – a nested list of causal factors subdivided by constitution levels</p></li>
<li><p><em>list of tuples of str</em> – list of pairs, each pair corresponds to an obtained equivalence formulae
in form of: element[0] &lt;-&gt; element[1]</p></li>
<li><p><em>list of lists of tuples</em> – nested list of pairs, for each constitution level, the order information are translated into
binary relations between factors (fac[0], fac[1]) means: fac[0] &lt; fac[1]</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/mlca-logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">Causal-mechanistic modeling using Coincidence Analysis</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=5vckcq&repo=https://github.com/5vckcq/multi-lvl-Coincidence-Analysis&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">mlca</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">mlca.atomic_formulae</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cli/index.html">mlca.cli</a></li>
<li class="toctree-l4"><a class="reference internal" href="../gui/index.html">mlca.gui</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mlca/index.html">mlca.mlca</a></li>
<li class="toctree-l4"><a class="reference internal" href="../plot_graph/index.html">mlca.plot_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utils/index.html">mlca.utils</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">API Reference</a><ul>
  <li><a href="../index.html">mlca</a><ul>
      <li>Previous: <a href="../index.html" title="previous chapter">mlca</a></li>
      <li>Next: <a href="../cli/index.html" title="next chapter">mlca.cli</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Johannes Mierau.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/autoapi/mlca/atomic_formulae/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>