<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>mlca.utils &#8212; multi-lvl-Coincidence Analysis  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="mlca.plot_graph" href="../plot_graph/index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-mlca.utils">
<span id="mlca-utils"></span><h1>mlca.utils<a class="headerlink" href="#module-mlca.utils" title="Link to this heading">¶</a></h1>
<p>utility functions, mostly string and list comparisons</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.powerset" title="mlca.utils.powerset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">powerset</span></code></a>(→ set)</p></td>
<td><p>Returns the powerset of the input in_set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.sort_by_second" title="mlca.utils.sort_by_second"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_by_second</span></code></a>(in_tuple)</p></td>
<td><p>Function that returns the second element of a tuple.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.list_comparison" title="mlca.utils.list_comparison"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list_comparison</span></code></a>(→ bool)</p></td>
<td><p>Compares two nested lists. Returns True iff the sorted lists with sorted sublists are equal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.flatten_nested_list" title="mlca.utils.flatten_nested_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten_nested_list</span></code></a>(→ list)</p></td>
<td><p>Flattens an homogenous list up to two times in case that it is a nested list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.find_causal_factors" title="mlca.utils.find_causal_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_causal_factors</span></code></a>(st)</p></td>
<td><p>Returns all substrings of st that are separated by &quot;, &quot; or &quot; &lt; &quot;.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.get_causal_prefactors" title="mlca.utils.get_causal_prefactors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_causal_prefactors</span></code></a>(→ list)</p></td>
<td><p>Returns a list of prefactors to a given factor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.get_equiv_formula" title="mlca.utils.get_equiv_formula"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_equiv_formula</span></code></a>(→ tuple)</p></td>
<td><p>Transforms a string into a tuple of strings (a,b) with the following characteristics:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.get_components_from_formula" title="mlca.utils.get_components_from_formula"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_components_from_formula</span></code></a>(→ list)</p></td>
<td><p>Returns a list of the elements of factor_list that appear in the input string st.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.get_factor_level" title="mlca.utils.get_factor_level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_factor_level</span></code></a>(→ int)</p></td>
<td><p>Returns the index of the sublist of the nested list level_factor_list which contains factor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.get_formula_level" title="mlca.utils.get_formula_level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_formula_level</span></code></a>(→ int)</p></td>
<td><p>Searches in string st for elements of sublists of level_factor_list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.get_factor_order" title="mlca.utils.get_factor_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_factor_order</span></code></a>(→ int)</p></td>
<td><p>Searches in sublists of second order of the nested list factor_list</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.get_formula_order" title="mlca.utils.get_formula_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_formula_order</span></code></a>(→ int)</p></td>
<td><p>Applies get_components_from_formula on formula and searches for all obtained</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.get_ordered_dnf" title="mlca.utils.get_ordered_dnf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ordered_dnf</span></code></a>(→ str)</p></td>
<td><p>Alphabetically orders all disjuncts and conjuncts in a string, assuming</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.get_clusters" title="mlca.utils.get_clusters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_clusters</span></code></a>(→ list)</p></td>
<td><p>Determines clusters of elements from factor_list that are connected via formulae</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.get_truthvalue" title="mlca.utils.get_truthvalue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_truthvalue</span></code></a>(→ bool)</p></td>
<td><p>Evaluates the truth value of a logical formula in DNF based on</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlca.utils.count_true" title="mlca.utils.count_true"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_true</span></code></a>(→ int)</p></td>
<td><p>Counts the number of truth value assignments to the variables in factor_list that make the logical</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlca.utils.get_coextensive_factors" title="mlca.utils.get_coextensive_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coextensive_factors</span></code></a>(→ list)</p></td>
<td><p>Determines which factors from factor_list are coextensive. Two factors A, B are coextensive</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.powerset">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">powerset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_set</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#mlca.utils.powerset" title="Link to this definition">¶</a></dt>
<dd><p>Returns the powerset of the input in_set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>in_set</strong> (<em>set</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>powerset of in_set = the set of all sets that can be formed of in_set and its elements</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.sort_by_second">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">sort_by_second</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_tuple</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlca.utils.sort_by_second" title="Link to this definition">¶</a></dt>
<dd><p>Function that returns the second element of a tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>in_tuple</strong> (<em>tuple</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>value = in_tuple[1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.list_comparison">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">list_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#mlca.utils.list_comparison" title="Link to this definition">¶</a></dt>
<dd><p>Compares two nested lists. Returns True iff the sorted lists with sorted sublists are equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list1</strong> (<em>list</em><em> of </em><em>lists</em>)</p></li>
<li><p><strong>list2</strong> (<em>list</em><em> of </em><em>lists</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if both lists are equivalent, else false</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.flatten_nested_list">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">flatten_nested_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.utils.flatten_nested_list" title="Link to this definition">¶</a></dt>
<dd><p>Flattens an homogenous list up to two times in case that it is a nested list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>in_list</strong> (<em>list</em>) – list that will be transformed
It is assumed that in_list is homogenous insofar that if the first element
is a list, all further elements are lists, too, and if the first element
is not a list, the further elements are neither.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>flattened list, up to two nested levels are removed and their elements
are direct elements of the returned list
empty list in case that in_list is not a list</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.find_causal_factors">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">find_causal_factors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">st</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlca.utils.find_causal_factors" title="Link to this definition">¶</a></dt>
<dd><p>Returns all substrings of st that are separated by “, “ or “ &lt; “.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>st</strong> (<em>str</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(possibly empty) list of substrings of st separated by “, “ or “ &lt; “</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_causal_prefactors">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_causal_prefactors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">formula_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.utils.get_causal_prefactors" title="Link to this definition">¶</a></dt>
<dd><p>Returns a list of prefactors to a given factor.</p>
<p>Prefactors are defined recursively. A prefactor of first order is a factor that
appears in the first element of a tuple whose second element is equal to the
given factor. Factors that appear in the first element of tuples whose second
element is a prefactor of order n are prefactors of order n+1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>factor</strong> (<em>str</em>) – factor for which the list of its prefactors is created</p></li>
<li><p><strong>formula_list</strong> (<em>list</em><em> of </em><em>2-tuples</em><em> of </em><em>str</em>) – tuples represent causal relations: first element represents the cause, second element the effect</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>str</em>) – list considered factors</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of prefactors to the given factor</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_equiv_formula">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_equiv_formula</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">st</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlca.utils.get_equiv_formula" title="Link to this definition">¶</a></dt>
<dd><p>Transforms a string into a tuple of strings (a,b) with the following characteristics:</p>
<ul class="simple">
<li><p>The substring “ &lt;-&gt; “ within the input st separates a from b. If st does not contain “ &lt;-&gt; “, b=’’. If
st contains multiple “ &lt;-&gt; “, b includes everything between the the first two instances of the separator.</p></li>
<li><p>Any white spaces or substrings followed by white spaces in a are removed.</p></li>
<li><p>If st contains any lower letter, they are replaced by the ‘~’ appended by the corresponding upper letter.</p></li>
<li><p>Any trailing white spaces in b or substrings following white spaces in b are removed.</p></li>
</ul>
<p>This procedure transforms output from cna into tuples (a, b), such that a + “ &lt;-&gt; “ + b
is a well-formed equivalence relation with a being a disjunctive normal form and b an atomic expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>st</strong> (<em>str</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_components_from_formula">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_components_from_formula</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">st</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.utils.get_components_from_formula" title="Link to this definition">¶</a></dt>
<dd><p>Returns a list of the elements of factor_list that appear in the input string st.
The returned list is empty if no factor from factor_list appears in st or factor_list is empty,
not a list of strings or not a list at all.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>st</strong> (<em>str</em>) – string which is searched for elements from factor_list</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>) – list whose elements are searched for in st</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>elements of factor_list that have been found in st or empty list</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_factor_level">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_factor_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#mlca.utils.get_factor_level" title="Link to this definition">¶</a></dt>
<dd><p>Returns the index of the sublist of the nested list level_factor_list which contains factor.
If factor is element in several sublists, the index of the first sublist is returned.
If the list is empty or the factor has not been found in any sublist return -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>factor</strong> (<em>str</em>) – string which is searched for in the sublists of level_factor_list</p></li>
<li><p><strong>level_factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list whose lowest level sublists are searched for factor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>index of sublist which contains factor, -1 if factor is not contained in
any sublist or list is empty</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_formula_level">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_formula_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">st</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#mlca.utils.get_formula_level" title="Link to this definition">¶</a></dt>
<dd><p>Searches in string st for elements of sublists of level_factor_list.
If all elements found are elements of the same sublist of level_factor_list,
return the index of this sublist, elsewise, return -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>st</strong> (<em>str</em>) – string which is tested for containing only elements of the same sublist</p></li>
<li><p><strong>level_factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list whose sublists are went through looking for substrings of str</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>index of the sublist to which all elements from</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_factor_order">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_factor_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#mlca.utils.get_factor_order" title="Link to this definition">¶</a></dt>
<dd><p>Searches in sublists of second order of the nested list factor_list
for factor. Returns the index of the first order sublist in whose sublist
factor has been found. If factor is contained in several sublists,
the lowest index is returned. If factor is not an element in any sublist, return -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>factor</strong> (<em>str</em>) – string which is searched for</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list whose sublists are went through looking for substrings of str</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>index of the sublist of factor_list whose sublist contains factor</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_formula_order">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_formula_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#mlca.utils.get_formula_order" title="Link to this definition">¶</a></dt>
<dd><p>Applies get_components_from_formula on formula and searches for all obtained
substrings in sublists of factor_list. If all substrings have been found, returns
the highest index of a sublist that contains a substring, elsewise, returns -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<em>str</em>) – string whose substrings are searched for in sublists of factor_list</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – nested list whose sublists are went through looking for substrings of str</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>highest index of sublist that contains substring of formula</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_ordered_dnf">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_ordered_dnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#mlca.utils.get_ordered_dnf" title="Link to this definition">¶</a></dt>
<dd><p>Alphabetically orders all disjuncts and conjuncts in a string, assuming
‘ + ‘ as disjunctor and ‘*’ as conjunctor. Returns the string with the
ordered formula. If formula is not a string, return ‘’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>formula</strong> (<em>str</em>) – string expected to contain a disjunctive normal form with disjunctor ‘ + ‘
or conjunctor ‘*’</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>string with alphabetically ordered formula</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_clusters">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.utils.get_clusters" title="Link to this definition">¶</a></dt>
<dd><p>Determines clusters of elements from factor_list that are connected via formulae
from formula_list. Two elements are connected if they appear in the same formula,
or if they both appear in formula within chain of formulae in which every formula
shares at least one element with any other formula of that chain.
Returns the list of clusters as a nested list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula_list</strong> (<em>list</em><em> of </em><em>2-tuples</em><em> of </em><em>str</em>) – list of 2-tuples of strings that a checked for connecting elements from
factor_list</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – possibly nested lists of strings</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of clusters of factors, each cluster contains all factors that are mutually
connected, returns a list containing the empty list if formula_list is empty or
not a list</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of lists of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_truthvalue">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_truthvalue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assignment</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#mlca.utils.get_truthvalue" title="Link to this definition">¶</a></dt>
<dd><p>Evaluates the truth value of a logical formula in DNF based on
a specified assignment of truth values to its variables.
If the formula is syntactically ill-formed or assignment does not
assign a truth value to all occuring variables, the function returns
False, otherwise it returns the truth value of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<em>list</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – Possibly nested list of string. Each string is expected to
contain one factor or a negated factor. Elements of sublists
are connected via conjunctors, the sublists via disjunctors.</p></li>
<li><p><strong>assignment</strong> (<em>dictionary</em><em> of </em><em>str -&gt; bool</em>) – Dictionary that assigns Boolean values to string entries.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if formula is well-formed, a truth value is assigned to
all variables and formula is True under this assignment.
False if (i) formula is ill-formed, (ii) assignment does not
contain truth value assignments to all variables of formula, or
(iii) formula is False under the given assignment.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.count_true">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">count_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#mlca.utils.count_true" title="Link to this definition">¶</a></dt>
<dd><p>Counts the number of truth value assignments to the variables in factor_list that make the logical
formula true. The formula is constructed by connecting both elements of each tuple in function_list
with an equivalence operator and combining all such equivalence expressions using conjunctors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function_list</strong> (<em>list</em><em> of </em><em>2-tuples</em><em> of </em><em>str</em>) – <p>List of 2-tuples of which the first element is expected to be a DNF using the syntactical rules:
* ‘*’ represents a conjunctor
* ‘~’ represents a negation
* ‘ + ‘ represents a disjunctor</p>
<p>The second element of each tuple is expected to be an atomic term.</p>
</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>) – (nested) list of factors that are possibly variables of the logical function from function_list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Amount of True values in the truth table for the given logical function function_list.
Returns 0, in case that function_list contains syntax errors, or if function_list
or factor_list is not a list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlca.utils.get_coextensive_factors">
<span class="sig-prename descclassname"><span class="pre">mlca.utils.</span></span><span class="sig-name descname"><span class="pre">get_coextensive_factors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlca.utils.get_coextensive_factors" title="Link to this definition">¶</a></dt>
<dd><p>Determines which factors from factor_list are coextensive. Two factors A, B are coextensive
if formula_list contains any of the following formulae: A &lt;-&gt; B, B &lt;-&gt; A, ~A &lt;-&gt; B or ~B &lt;-&gt; A.
Returns the list of clusters of coextensive factors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula_list</strong> (<em>list</em><em> of </em><em>2 tuples</em><em> of </em><em>str</em>) – list of tuples of strings, expected to be composed of elements from factor_list,
the second component of each tuple is assumed to be an atomic term, the first
can be complex</p></li>
<li><p><strong>factor_list</strong> (<em>list</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>str</em><em> or </em><em>list</em><em> of </em><em>lists</em><em> of </em><em>lists</em><em> of </em><em>str</em>) – possibly nested list of factors</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>nested list of clusters with coextensive variables
empty list if there are no coextensive variables</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/mlca-logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">Causal-mechanistic modeling using Coincidence Analysis</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=5vckcq&repo=https://github.com/5vckcq/multi-lvl-Coincidence-Analysis&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">mlca</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../atomic_formulae/index.html">mlca.atomic_formulae</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cli/index.html">mlca.cli</a></li>
<li class="toctree-l4"><a class="reference internal" href="../gui/index.html">mlca.gui</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mlca/index.html">mlca.mlca</a></li>
<li class="toctree-l4"><a class="reference internal" href="../plot_graph/index.html">mlca.plot_graph</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">mlca.utils</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">API Reference</a><ul>
  <li><a href="../index.html">mlca</a><ul>
      <li>Previous: <a href="../plot_graph/index.html" title="previous chapter">mlca.plot_graph</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Johannes Mierau.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/autoapi/mlca/utils/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>