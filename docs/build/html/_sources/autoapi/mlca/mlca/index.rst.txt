mlca.mlca
=========

.. py:module:: mlca.mlca

.. autoapi-nested-parse::

   This file contains the main functions of multi-Lvl-Coincidence-Analysis (mLCA), a package to
   generate multi-level causal-mechanistic models from Boolean data tables that are provided with
   tiered list of causal factors (assignment to constitutive levels).

   The data tables can be processed in three different ways:

   A. as csv-files with Boolean data (for details on formatting requirements
      see README),
   B. reading the atomic solutions from the output of the R-package cna,
   C. or from the output of the QCA package.

   If any of the two latter options is used, it is assumed that causal factors pertaining to
   different levels are separated by the causal ordering relation "<".
   Relations between factors of different levels are not considered as causal but constitution relations.

   ..
       !! processed by numpydoc !!


Functions
---------

.. autoapisummary::

   mlca.mlca.is_transitive
   mlca.mlca.reduce_structural_redundancy
   mlca.mlca.minimise_constitution_relations
   mlca.mlca.arrange_factors
   mlca.mlca.read_input
   mlca.mlca.categorise_formulae
   mlca.mlca.determine_factor_order
   mlca.mlca.reduce_redundancies
   mlca.mlca.find_conflicting_formulae
   mlca.mlca.convert_tuple_list_to_nested_list
   mlca.mlca.find_structures
   mlca.mlca.create_separate_formula_list


Module Contents
---------------

.. py:function:: is_transitive(formula_list: list, factor_list: list) -> tuple[list, bool]

   
   Function that checks whether the list of causal relations is transitive for the causal factors
   from factor_list, e.g., A->B, B->C is transitive, but A->B, B->C, C->A is not.

   If it is transitive, the function defines a causal ordering on factor_list and returns
   it in a nested list.

   :param formula_list: list of equivalence formulae, first element
   :type formula_list: list of tuples of str
   :param factor_list:
   :type factor_list: list of str or list of list of str or list of list of str

   :returns: * *bool* -- True if value whether transitive
               False otherwise
             * **order_factor_list** (*list of lists of str or list of str*) -- If first returned value is False, return the initial factor_list.
               If first returned value is True, return a nested list of causal factors
               subdivided by their causal order of the form order_factor_list[ORDER][FACTOR].
               list is empty if factor_list is empty















   ..
       !! processed by numpydoc !!

.. py:function:: reduce_structural_redundancy(factor_list: list, formula_list: list, reduced_solutions_list=[], already_tested=[]) -> tuple[bool, list]

   
   Reduces the list of equivalence relations to dissolve structural redundancies.

   All factors that are causally connected through formula_list remain causally connected,
   while a linear ordering of the causal factors can be defined, which is only interesting in
   case that this is not possible for formula_list itself.

   :param factor_list: list of factors, expected to contain all variables of formulae from formula_list
   :type factor_list: list of str
   :param formula_list: list equivalence relations represented as tuples, first element corresponds to the
                        complex DNF-term, second element to the atomic term
   :type formula_list: list of tuples of str
   :param reduced_solutions_list: list of formula lists that are free of structural redundancies, with recursive
                                  invocations of this function, elements get added to this list
   :type reduced_solutions_list: list of lists of tuples of str, optional
   :param already_tested: list to keep track of formual lists that have already been tested for
                          being redundancy-free, every formula_list gets added to avoid testing the same
                          formula list several times
   :type already_tested: list of lists of tuples of str, optional

   :returns: * *bool* -- truth value whether structural redundancy-free solutions have been found
             * *list* -- list of formula lists that correspond to non-circular solutions that are logically
               equivalent to formula_list if any has been found;
               OR the list contains only the incomming formula_list if no non-circular solution has been found















   ..
       !! processed by numpydoc !!

.. py:function:: minimise_constitution_relations(level_factor_list_order: list, level: int, level_equiv_list: list, constitution_relation_list: list, color_map: dict, color_index: int, mode=[]) -> tuple

   
   Transforms constitution relations and discards inaccurate constitution relations.

   Constitution relations are inaccurate if the lower order factors are in fact constituents of an upstream higher order factor
   relative to the higher order factor that appears in the constitution relation.
   steps:

   1. constitution relations are rewritten, complex formulae in the constituents are split up into separate constitution
      relations (e.g. ('A*B','C') becomes ('A','C'),('B','C')
      in this step, an individual list for each higher order factor for which constitution relations exist is created
   2.

      A) find the highest order of constituents -> factors of this order are kept for sure
      B) determine the lowest order that should be kept

        i) if the higher level factor is of order 0 (on level m), factors of downto order 0 (on level m-1) should be kept
        ii) if the higher level factor is of a higher order, its lowest factors must not be in constitution relation
            with the factor's causal pre-factors
   3. discard constitution relations to terms that are middle terms of causal chains whose
      upstream and downstream factors are also in a constitution relation with the considered higher level factor

   :param level_factor_list_order: nested list of factors in form of level_factor_list_order[LEVEL][ORDER][FACTOR]
   :type level_factor_list_order: list of lists of lists of str
   :param level: index of the considered constitutive level
   :type level: int
   :param level_equiv_list: nested list of equivalence relations (causal) represented as tuples, first element corresponds to the
                            complex DNF-term, second element to the atomic term
   :type level_equiv_list: list of lists of tuples of str
   :param constitution_relation_list: list of equivalence relations (constitutive) represented as tuples, first element corresponds to the
                                      complex DNF-term, second element to the atomic term
   :type constitution_relation_list: list of tuples of str
   :param color_map: dictionary of the form [STYLE][FACTOR] that contains for each factor in which color the nodes are drawn
                     (STYLE='draw'), and the labels are written (STYLE='text')
   :type color_map: dict
   :param color_index: index of the color in which the constitution relations will be drawn,
                       color index values 0,1,...,11 are defined in Latex_Template
   :type color_index: int
   :param mode: list of special options, such as black-white plotting, empty list means that no special option is used
   :type mode: list of str, optional

   :returns: * *list of tuples of str* -- reduced list of constitution relations
             * *dict* -- modified color_map
             * *int* -- color_index of color for next constitution relation















   ..
       !! processed by numpydoc !!

.. py:function:: arrange_factors(level_factor_list_order: list, level_equiv_list: list, constitution_relation_list: list, mode=[]) -> tuple

   
   Prepares the factor list for plotting such that the nodes are arranged to minimise crossings of vertices in the hypergraph.

   A) factors of same level and order zero are grouped when belonging to the same constitution relation
   B) factors of same level and subsequent orders are arranged such that arrow crossing in the causal graphs becomes minimised
      (in a very rudimentary way)
   C) discards constitution relations for middle terms

   :param level_factor_list_order: nested list of factors in form of level_factor_list_order[LEVEL][ORDER][FACTOR]
   :type level_factor_list_order: list of lists of lists of str
   :param level_equiv_list: nested list of equivalence relations (causal) represented as tuples, first element corresponds to the
                            complex DNF-term, second element to the atomic term
   :type level_equiv_list: list of lists of tuples of str
   :param constitution_relation_list: list of equivalence relations (constitutive) represented as tuples, first element corresponds to the
                                      complex DNF-term, second element to the atomic term
   :type constitution_relation_list: list of tuples of str
   :param mode: list of special options, such as black-white plotting, empty list means that no special option is used
   :type mode: list of str, optional

   :returns: * *list of lists of lists of str* -- modified level_factor_list_order
             * *list of tuples of str* -- modified constitution_relation_list
             * *dict* -- dictionary of the form [STYLE][FACTOR] that contains for each factor in which color the nodes are drawn
               (STYLE='draw'), and the labels are written (STYLE='text')
             * *list of lists of tuples of str* -- modified level_equiv_list















   ..
       !! processed by numpydoc !!

.. py:function:: read_input(file_name: str) -> tuple

   
   Obtains the relevant data from the R output of either QCA or CNA and returns two lists:

   (1) level_factor_list - list of causal factors separated into one sublist for each constitutive level,
   (2) equiv_list - list of equivalence formulae

   Functionality depends on the output syntax of both R-packages and is adapted to CNA version 3.5.4;
   QCA version 3.21.
   This function has to be adjusted to any changes in the output formatting of these packages.

   :param file_name: path to the text file containing the results from QCA or CNA
   :type file_name: str

   :returns: * *bool* -- truth value of whether an error occured while reading and evaluating file_name
             * *list of lists of str* -- nested list of factors, in form level_factor_list[LEVEL][FACTOR]
             * *list of tuples of str* -- list of equivalence relations in form of tuples















   ..
       !! processed by numpydoc !!

.. py:function:: categorise_formulae(equiv_list: list, level_factor_list: list) -> tuple

   
   Separates the equivalence relations in causal relations (subdivided by their constitutive level) and constitution relations.
   All further equivalence relations from equiv_list are discarded.

   :param equiv_list: list of equivalence relations in form of tuples
   :type equiv_list: list of tuples of str
   :param level_factor_list: nested list factors, expected to contain all variables of formulae from equiv_list
   :type level_factor_list: list of lists of str

   :returns: * *list of lists of tuples of str* -- nested list causal relations per constitutive level, in form of
               level_equiv_list[LEVEL][FORMULA](COMPLEX_TERM,ATOMIC_TERM)
             * *list of tuples of str* -- list constitution relations















   ..
       !! processed by numpydoc !!

.. py:function:: determine_factor_order(level_factor_list: list, level_equiv_list: list) -> list

   
   Uses the list of causal relations in level_equiv_list to determine a total causal ordering of the causal factors
   in level_factor_list for each level separately.

   Returns the new factor list level_factor_list_order that is nested twice by level and causal order
   level_factor_list_order[LEVEL][ORDER][FACTOR].

   :param level_factor_list: nested list factors, expected to contain all variables of formulae from equiv_list
   :type level_factor_list: list of lists of str
   :param level_equiv_list: nested list of equivalence relations per level in form of tuples
   :type level_equiv_list: list of lists of tuples of str

   :returns: level_factor_list_order that is nested twice by level and causal order in form of
             level_factor_list_order[LEVEL][ORDER][FACTOR]
   :rtype: list of lists of lists of str















   ..
       !! processed by numpydoc !!

.. py:function:: reduce_redundancies(level_factor_list: list, level_equiv_list: list) -> tuple

   
   Determines the (non-strict) transitive order of the causal factors and
   adapts the causal order to particular solution.

   Returns all models that can be generated from level_equiv_list by removing
   redundancies.

   :param level_factor_list: nested list factors, expected to contain all variables of formulae from equiv_list
   :type level_factor_list: list of lists of str
   :param level_equiv_list: nested list of equivalence relations per level in form of tuples
   :type level_equiv_list: list of lists of tuples of str

   :returns: * *bool* -- truth value of non-circularity of obtained models
             * *list of tuples* -- list of models in form of pairs of nested factor list (by level and order),
               and nested causal relations list (by level)















   ..
       !! processed by numpydoc !!

.. py:function:: find_conflicting_formulae(solution: list) -> dict

   
   Function that searches in a list of tupels for elements that share the second value.

   In the context of mLCA, the function finds all conflicting causal relations (those to a same effect) in a proposed model
   and returns them ordered by effect.

   :param solution: list of equivalence relations per level in form of tuples
   :type solution: list of tuples of str

   :returns: dictionary whose keys are the multiple second tuple-values and the assigned dictionary-values are lists of the corresponding
             first tuple-values
   :rtype: dict















   ..
       !! processed by numpydoc !!

.. py:function:: convert_tuple_list_to_nested_list(in_list: list) -> list

   
   Transforms lists of tuples into a nested list and returns the nested list.

   :param in_list: list of tuples or nested list
   :type in_list: list

   :returns: a nested list, in case that in_list is a list of tuples, the tuples are transformed
             into sublists
   :rtype: list of lists















   ..
       !! processed by numpydoc !!

.. py:function:: find_structures(in_level_factor_list: list, in_level_equiv_list: list, mode=['bw', 'simple'], pos_caus_cond=[], neg_caus_cond=[]) -> list

   
   This functions combines the causal relations to solutions for the underlying multi-level structure.
   Each solution consists of a minimal set of causal relations to causally connect every causal factor.
   find_structures returns a list with all valid solutions in form of a list of solutions, which are nested lists of causal relations
   per constitutive level in the form of solutions_list[SOLUTION][LEVEL][CAUSAL RELATION].

   Since combining all causal relations that can logically be generated from the truth table
   can lead to various causal relations for the same effect, as well as formulae where an effect
   might appear as cause of its own cause, some formulae have to be ignored when creating
   the causal structure of the mechanism. This happens with the following steps:
   for each consitution level separate steps:

   A. find circular sub-structures
   B. discard as many causal relations as necessary to get rid of all simple circularities
   C. find causal relations that have the same effect
   D. compose the list of all valid solutions (it consists of all combinations of valid solution
      each consisting of one formula per effect of step A combined with one possible resolution of
      circularities and those formulae that are the common core of all valid structures)
      combining the partial solutions for each constitutive level
   E. Cartesian product of the partial solutions - also discard dublicates of solutions and solutions
      that only differ in the order of formulae

   :param in_level_factor_list: nested list of lists of causal factors per constitutive level
   :type in_level_factor_list: list of lists of str
   :param in_level_equiv_list: nested list of lists of equivalence relations per constitutive level (all of them are interpreted as causal relations)
   :type in_level_equiv_list: list of lists of tuples of str
   :param mode:
                list of options: "simple" is faithful to the INUS theory of causation (default option),
                                 "complex" emits further models with more complex relations between co-extensive
                                  factors (not only A <-> B, B <-> C, etc., but also A*B <-> C, A + B <-> C)
   :type mode: list of str, optional
   :param pos_caus_cond: list of equivalence relations that are required to appear in each model (by default empty) # MARKER TO-DO to be integrated into the code
   :type pos_caus_cond: list of tuples of str, optional
   :param neg_caus_cond: list of equivalence relations that must not appear in any model (by default empty) # MARKER TO-DO to be integrated
   :type neg_caus_cond: list of tuples of str, optional

   :returns: list of all valid solutions in the form of solutions_list[SOLUTION][LEVEL][CAUSAL RELATION]
   :rtype: list of lists of lists of tuples of str















   ..
       !! processed by numpydoc !!

.. py:function:: create_separate_formula_list(formula_list: list) -> None

   
   Creates a text file listing all possible causal structures as tex-formulae.

   :param formula_list: list of formulae to be exported in tex-file, expected to be already converted
                        into tex-syntax
   :type formula_list: list of str















   ..
       !! processed by numpydoc !!

