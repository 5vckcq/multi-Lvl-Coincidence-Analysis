mlca.utils
==========

.. py:module:: mlca.utils

.. autoapi-nested-parse::

   utility functions, mostly string and list comparisons

   ..
       !! processed by numpydoc !!


Functions
---------

.. autoapisummary::

   mlca.utils.powerset
   mlca.utils.sort_by_second
   mlca.utils.list_comparison
   mlca.utils.flatten_nested_list
   mlca.utils.find_causal_factors
   mlca.utils.get_causal_prefactors
   mlca.utils.get_equiv_formula
   mlca.utils.get_components_from_formula
   mlca.utils.get_factor_level
   mlca.utils.get_formula_level
   mlca.utils.get_factor_order
   mlca.utils.get_formula_order
   mlca.utils.get_ordered_dnf
   mlca.utils.get_clusters
   mlca.utils.get_truthvalue
   mlca.utils.count_true
   mlca.utils.get_coextensive_factors


Module Contents
---------------

.. py:function:: powerset(in_set: set) -> set

   
   Returns the powerset of the input in_set.

   :param in_set:
   :type in_set: set

   :returns: powerset of in_set = the set of all sets that can be formed of in_set and its elements
   :rtype: set















   ..
       !! processed by numpydoc !!

.. py:function:: sort_by_second(in_tuple: tuple)

   
   Function that returns the second element of a tuple.

   :param in_tuple:
   :type in_tuple: tuple

   :rtype: value = in_tuple[1]















   ..
       !! processed by numpydoc !!

.. py:function:: list_comparison(list1: list, list2: list) -> bool

   
   Compares two nested lists. Returns True iff the sorted lists with sorted sublists are equal.

   :param list1:
   :type list1: list of lists
   :param list2:
   :type list2: list of lists

   :returns: True if both lists are equivalent, else false
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: flatten_nested_list(in_list: list) -> list

   
   Flattens an homogenous list up to two times in case that it is a nested list.

   :param in_list: list that will be transformed
                   It is assumed that in_list is homogenous insofar that if the first element
                   is a list, all further elements are lists, too, and if the first element
                   is not a list, the further elements are neither.
   :type in_list: list

   :returns: flattened list, up to two nested levels are removed and their elements
             are direct elements of the returned list
             empty list in case that in_list is not a list
   :rtype: list















   ..
       !! processed by numpydoc !!

.. py:function:: find_causal_factors(st)

   
   Returns all substrings of st that are separated by ", " or " < ".

   :param st:
   :type st: str

   :returns: (possibly empty) list of substrings of st separated by ", " or " < "
   :rtype: list















   ..
       !! processed by numpydoc !!

.. py:function:: get_causal_prefactors(factor: str, formula_list: list, factor_list: list) -> list

   
   Returns a list of prefactors to a given factor.

   Prefactors are defined recursively. A prefactor of first order is a factor that
   appears in the first element of a tuple whose second element is equal to the
   given factor. Factors that appear in the first element of tuples whose second
   element is a prefactor of order n are prefactors of order n+1.

   :param factor: factor for which the list of its prefactors is created
   :type factor: str
   :param formula_list: tuples represent causal relations: first element represents the cause, second element the effect
   :type formula_list: list of 2-tuples of str
   :param factor_list: list considered factors
   :type factor_list: list of str

   :returns: list of prefactors to the given factor
   :rtype: list of str















   ..
       !! processed by numpydoc !!

.. py:function:: get_equiv_formula(st: str) -> tuple

   
   Transforms a string into a tuple of strings (a,b) with the following characteristics:

   * The substring " <-> " within the input st separates a from b. If st does not contain " <-> ", b=''. If
     st contains multiple " <-> ", b includes everything between the the first two instances of the separator.
   * Any white spaces or substrings followed by white spaces in a are removed.
   * If st contains any lower letter, they are replaced by the '~' appended by the corresponding upper letter.
   * Any trailing white spaces in b or substrings following white spaces in b are removed.

   This procedure transforms output from cna into tuples (a, b), such that a + " <-> " + b
   is a well-formed equivalence relation with a being a disjunctive normal form and b an atomic expression.

   :param st:
   :type st: str

   :rtype: tuple of str















   ..
       !! processed by numpydoc !!

.. py:function:: get_components_from_formula(st: str, factor_list: list) -> list

   
   Returns a list of the elements of factor_list that appear in the input string st.
   The returned list is empty if no factor from factor_list appears in st or factor_list is empty,
   not a list of strings or not a list at all.

   :param st: string which is searched for elements from factor_list
   :type st: str
   :param factor_list: list whose elements are searched for in st
   :type factor_list: list of lists of lists of str or list of lists of str or list of str

   :returns: elements of factor_list that have been found in st or empty list
   :rtype: list of str















   ..
       !! processed by numpydoc !!

.. py:function:: get_factor_level(factor: str, level_factor_list: list) -> int

   
   Returns the index of the sublist of the nested list level_factor_list which contains factor.
   If factor is element in several sublists, the index of the first sublist is returned.
   If the list is empty or the factor has not been found in any sublist return -1.

   :param factor: string which is searched for in the sublists of level_factor_list
   :type factor: str
   :param level_factor_list: nested list whose lowest level sublists are searched for factor
   :type level_factor_list: list of lists of str or list of lists of lists of str

   :returns: index of sublist which contains factor, -1 if factor is not contained in
             any sublist or list is empty
   :rtype: int















   ..
       !! processed by numpydoc !!

.. py:function:: get_formula_level(st: str, level_factor_list: list) -> int

   
   Searches in string st for elements of sublists of level_factor_list.
   If all elements found are elements of the same sublist of level_factor_list,
   return the index of this sublist, elsewise, return -1.

   :param st: string which is tested for containing only elements of the same sublist
   :type st: str
   :param level_factor_list: nested list whose sublists are went through looking for substrings of str
   :type level_factor_list: list of lists of str or list of lists of lists of str

   :returns: index of the sublist to which all elements from
   :rtype: int















   ..
       !! processed by numpydoc !!

.. py:function:: get_factor_order(factor: str, factor_list: list) -> int

   
   Searches in sublists of second order of the nested list factor_list
   for factor. Returns the index of the first order sublist in whose sublist
   factor has been found. If factor is contained in several sublists,
   the lowest index is returned. If factor is not an element in any sublist, return -1.

   :param factor: string which is searched for
   :type factor: str
   :param factor_list: nested list whose sublists are went through looking for substrings of str
   :type factor_list: list of lists of lists of str

   :returns: index of the sublist of factor_list whose sublist contains factor
   :rtype: int















   ..
       !! processed by numpydoc !!

.. py:function:: get_formula_order(formula: str, factor_list: list) -> int

   
   Applies get_components_from_formula on formula and searches for all obtained
   substrings in sublists of factor_list. If all substrings have been found, returns
   the highest index of a sublist that contains a substring, elsewise, returns -1.

   :param formula: string whose substrings are searched for in sublists of factor_list
   :type formula: str
   :param factor_list: nested list whose sublists are went through looking for substrings of str
   :type factor_list: list of lists of lists of str

   :returns: highest index of sublist that contains substring of formula
   :rtype: int















   ..
       !! processed by numpydoc !!

.. py:function:: get_ordered_dnf(formula: str) -> str

   
   Alphabetically orders all disjuncts and conjuncts in a string, assuming
   ' + ' as disjunctor and '*' as conjunctor. Returns the string with the
   ordered formula. If formula is not a string, return ''.

   :param formula: string expected to contain a disjunctive normal form with disjunctor ' + '
                   or conjunctor '*'
   :type formula: str

   :returns: string with alphabetically ordered formula
   :rtype: str















   ..
       !! processed by numpydoc !!

.. py:function:: get_clusters(formula_list: list, factor_list: list) -> list

   
   Determines clusters of elements from factor_list that are connected via formulae
   from formula_list. Two elements are connected if they appear in the same formula,
   or if they both appear in formula within chain of formulae in which every formula
   shares at least one element with any other formula of that chain.
   Returns the list of clusters as a nested list.

   :param formula_list: list of 2-tuples of strings that a checked for connecting elements from
                        factor_list
   :type formula_list: list of 2-tuples of str
   :param factor_list: possibly nested lists of strings
   :type factor_list: list of str or list of lists of str or list of lists of lists of str

   :returns: list of clusters of factors, each cluster contains all factors that are mutually
             connected, returns a list containing the empty list if formula_list is empty or
             not a list
   :rtype: list of lists of str















   ..
       !! processed by numpydoc !!

.. py:function:: get_truthvalue(formula: list, assignment: dict) -> bool

   
   Evaluates the truth value of a logical formula in DNF based on
   a specified assignment of truth values to its variables.
   If the formula is syntactically ill-formed or assignment does not
   assign a truth value to all occuring variables, the function returns
   False, otherwise it returns the truth value of the function.

   :param formula: Possibly nested list of string. Each string is expected to
                   contain one factor or a negated factor. Elements of sublists
                   are connected via conjunctors, the sublists via disjunctors.
   :type formula: list of str or list of lists of str
   :param assignment: Dictionary that assigns Boolean values to string entries.
   :type assignment: dictionary of str -> bool

   :returns: True if formula is well-formed, a truth value is assigned to
             all variables and formula is True under this assignment.
             False if (i) formula is ill-formed, (ii) assignment does not
             contain truth value assignments to all variables of formula, or
             (iii) formula is False under the given assignment.
   :rtype: bool















   ..
       !! processed by numpydoc !!

.. py:function:: count_true(function_list: list, factor_list: list) -> int

   
   Counts the number of truth value assignments to the variables in factor_list that make the logical
   formula true. The formula is constructed by connecting both elements of each tuple in function_list
   with an equivalence operator and combining all such equivalence expressions using conjunctors.

   :param function_list: List of 2-tuples of which the first element is expected to be a DNF using the syntactical rules:
                         * '*' represents a conjunctor
                         * '~' represents a negation
                         * ' + ' represents a disjunctor

                         The second element of each tuple is expected to be an atomic term.
   :type function_list: list of 2-tuples of str
   :param factor_list: (nested) list of factors that are possibly variables of the logical function from function_list
   :type factor_list: list of lists of lists of str or list of lists of str or list of str

   :returns: Amount of True values in the truth table for the given logical function function_list.
             Returns 0, in case that function_list contains syntax errors, or if function_list
             or factor_list is not a list.
   :rtype: int















   ..
       !! processed by numpydoc !!

.. py:function:: get_coextensive_factors(formula_list: list, factor_list: list) -> list

   
   Determines which factors from factor_list are coextensive. Two factors A, B are coextensive
   if formula_list contains any of the following formulae: A <-> B, B <-> A, ~A <-> B or ~B <-> A.
   Returns the list of clusters of coextensive factors.

   :param formula_list: list of tuples of strings, expected to be composed of elements from factor_list,
                        the second component of each tuple is assumed to be an atomic term, the first
                        can be complex
   :type formula_list: list of 2 tuples of str
   :param factor_list: possibly nested list of factors
   :type factor_list: list of str or list of lists of str or list of lists of lists of str

   :returns: nested list of clusters with coextensive variables
             empty list if there are no coextensive variables
   :rtype: list















   ..
       !! processed by numpydoc !!

